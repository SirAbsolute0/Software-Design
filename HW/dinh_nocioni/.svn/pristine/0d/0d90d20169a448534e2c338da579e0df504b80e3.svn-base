HW3 Due 11:59PM April 21

***Please review the top part of ../hw1/hw1.txt***
***Your chance of success greatly increases if you start very early. Your chance of failure increases if you start late. Please use as many reviews as you possibly can.***

1. According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far.

According to the article, there are four rules to simple design: passes the tests, reveals intention, no duplication, and fewest elements. These rules are essential to software development because it separates well-design, scalable, and maintainable code from poorly-designed and hard-to-understand code. Having a well-design code base provides flexibility for additional features in the future while still maintaining the core functionality of the original design, which can massively affect the revenue of any software-related business since a well-design code foundation will minimize the amount of time relearning and rebuilding. We have consistently applied these techniques throughout the assignments, specifically through the YAGNI, DRY, and SRP principles which have shown significant benefits in the development cycle of our works. 

Ranking in order of importance, Martin Fowler ranks passing the tests as the highest priority out of the four rules. The tests ensure that each functionality of the program works as intended; thus, if the tests pass, it means that, at the bare minimum, the functionality tie to each test case is working correctly. As the program increases in complexity, so will the importance of these tests, as they give the developers confidence that the newly added functionalities do not alter any previous work. In practice, if each program's functionality has its test case, the developers will never have to worry about a program misbehaving when developing new functionalities. In business, while it is not feasible to cover the program with every test case, if the program's core functionality is ensured with proper tests, at least the program will continue to perform its main tasks for the users during the development cycle of a new feature.

The second level of importance includes both revealed intention and no duplication. It is critical to reveal intention because code is not only written for machines but also for people. Similar to an essay, the flow of a program should be cohesive and flow smoothly from function to function. It is also essential to be specific and consistent with the naming scheme, as different developers can interpret undefined variables and function names differently. Thus, it can cause many unnecessary headaches in the development cycle with multiple working on the same program. Fortunately, revealing intention in software is not costly to implement. Specifically, it only requires the self-discipline of each developer in a team to have a good naming scheme for their parts in the design. If implemented correctly, the benefits of having well-revealed code for a business or project are massive since it is easier to alter, add new functionalities, and maintain by new developers.

Of equal importance to revealing intention, no duplication is also crucial for a good design. In many ways, no duplication helps reveal intention because it reduces clutter inside a program, which helps the program flow. Furthermore, duplication in code can cause a ripple effect throughout the code if one copy is changed while another is not. Consistent is essential, and a function change should reflect everywhere else the function is present. In practice and business, having no duplication while increasing the development time slightly in the present but significantly reducing the refactoring time in the future.

The fewest elements rule is the last of the four at the lowest priority. The fewest elements rule is if "anything that does not serve the three prior rules should be removed." The last rule helps limit unnecessary complexity during development. Like no duplication, it also helps decrease clutter, increase code flow, and increase cohesiveness. However, it does not immediately affect the program since having more complexity does not really change how a program functions. Still, it is a crucial rule to reduce the work hours of developers on non-essential complexity while changing their focus on tasks with higher priority.

We have applied these four rules through YAGNI, DRY, and SRP throughout the assignments in constructing our code. When starting a new design with YAGNI, we build a test for the functionality and then implement minimal code to pass the test. YAGNI ensures that the core functionality of our code is constantly tested, fulfilling rule number one out of the four rules of simple design. Moreover, YAGNI ensures we do not add unnecessary complexity to our design which is the fourth rule. Meanwhile, the SRP principle maintains the flow of our program, with each function doing only one thing and each function and variable having a proper naming scheme. SRP is fulfilling the reveal intention rule. Lastly, the DRY principle does not let us overlap code with similar functionality; instead, we have to redesign the function to suit all our needs. DRY is fulfilling the last rule of simple design: no duplication. 

Overall, the four simple design rules are passing the tests, revealing intention, no duplication, and having the fewest elements. Each of them brings benefits to software during and after the development cycle. Some benefits are increased code cohesiveness, reduced duplicate work, better manageability, and maintainability in the future. We have applied these four rules throughout the past assignments using YAGNI, SRP, and DRY, which have shown significant benefits.

2. Also give from examples outside of this class, but limit to your personal experiences. Mention your name and below that provide details of your experience related to the rules, but outside of this class.

Phuong Dinh:

While I have not worked in an environment where I can apply the four rules of simple design, I am considering incorporating them in my next project. More specifically, the work I have done previously for my personal, class, or professional projects have always been prototype-like, with a small team of about three members. Thus, I found it challenging to spend precious development time adhering to the four rules of simple design. However, after implementing these rules through different designing principles such as YAGNI, DRY, SRP, OCP, etc. It is becoming increasingly apparent that I must apply the four directions to design a proper program for current usage and future maintainability. For example, I now appreciate the use of test cases much more since I have recently added a new feature to my program, but it breaks the logic. I had to spend multiple days tracking down where the error logic was coming from since it went through numerous function calls. I am confident that problems like this will continue as the program becomes increasingly complex. Eventually, the design would need to be rewritten entirely, or nobody, including myself, could understand the code anymore. Therefore, I am looking into incorporating YAGNI, DRY, and SRP into my following projects to see the effectiveness of the principles toward my work flow.
