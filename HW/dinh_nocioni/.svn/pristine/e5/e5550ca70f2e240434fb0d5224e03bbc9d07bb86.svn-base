Please keep all files related to a homework or an assignment within the appropriate directory. Files checked in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Reasonable effort is expected from each person. If you do not check in, you will not receive any scores. When pairing please switch who checks in so there is significant number of check in from each of you.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat or to the mailing list. Your last check in before the deadline will be graded. If your last check in breaks the code, both you and your pair will lose significant points.

Please feel free to ask for frequent reviews. See the reviews/readme.txt file for details on how to ask for reviews.

You can evolve the answers and solutions based on the reviews. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

You are still responsible to successfully complete an homework or assignment even if your pair is a no-show. You can request to change pairs at any time and if there is another person in the class willing to pair with you we can make the switch.

A lot of help will be provided in this course, but you have to start early and ask for help along the way.                                                                      

Please read the academic honesty policy posted on the course mailing list.                   

The above details apply to all homework and assignments in this course.                   

Now to homework #1.
==============================================================================
HW1: Due 11:59PM CT February 3

Is design dead according to Martin Fowler in 
<http://martinfowler.com/articles/designDead.html>?

Q1. What are some of the main observations he makes about how we should design?

	In the article "Is Design Dead?" the author, Martin Fowler, discusses the rising of Extreme Programming (XP) practices which could significantly affect the future view of design in software development. Based on XP practices, Martin points out four critical observations on how we as a programmer should do design. These four key observations are effective design patterns, understanding the design architecture, utilization of diagrams, and rapid spotting.

	According to Martin, a practical design pattern means we understand the price of a pattern worth paying. Specifically, we need to be more familiar with gradually easing into a pattern. Practical usage of patterns will simplify future refactoring since many patterns can be traced back to GOF for reference. Some advice for improving pattern utilization is investing time in learning about patterns, concentrating on when and how to apply the pattern in its simplest form, and finally, do not be afraid to remove unnecessary patterns.

	Along with the usage of patterns, it is also crucial to understand the design architecture. The author suggests starting by accessing the likely architecture but being ready to simplify the architecture as soon as a part of the architecture is not adding anything. The first design will give a general work guideline but also leaves room for improvement or removal later in the future.

	Martin highlights the usage of diagrams in the design phase. He suggests that we as designers should remember the purpose of drawing diagrams. Furthermore, only draw things that are necessary to communicate the right message. Diagrams can also be a valuable tool for exploring a design before coding. A diagram is the most effective when everyone can access it; thus, it should be shared between teammates. If no one uses the diagram, it should be discarded.

	Lastly, rapid spotting is essential for design since software should be set up to test potential problem areas rapidly. Rapid spotting helps identify issues along the development. It also means that it is worth experimenting to see how hard future changes can be.

	In summary, while the new rise of XP development practices seems to oppose traditional designing practices, Martin concludes that it will not entirely replace designing. Furthermore, there are several designing practices, such as effective design patterns, understanding design architecture, utilization of diagrams, and rapid spotting, that XP developers can consider to develop better well-rounded software.

Q2. Relate these recommendations to your personal experiences, where it may have 
worked or may not have worked for you.

Phuong:
	As an undergraduate student, much of my programming experiences come from Computer Science courses within the university. Since I usually develop prototypes within these courses rather than complete software with a development cycle, I rarely have to exercise the software design phase. To me, it is not a worthwhile time investment to do a design for every homework problem. Thus, I have never carefully considered the design phase before coding a homework problem. Therefore, I would say that I am currently leaning more toward the XP development side. Out of the four critical observations from Martin Fowler, I have only utilized rapid spotting and diagrams. I use unit testing to detect problems with my code for rapid spotting so I can quickly address bugs. In terms of diagrams, it was to line out the layout for a database, so it was a requirement. Apart from spotting design and diagram utilization, I have yet to utilize design patterns and architecture.


Fred:
Throughout my time as an undergrad student I have always subconciously neglected the design phase of software development as ideas came to me and wanted to create drafts of them as code as soon as possible. The approach led to me refactoring sections of code many times; Reflecting on these moments I realize that a certain degree of planning (either through UML or other methods) could have saved some time.
However, when I had my internship in Discover PULSE as an application engineer I found that extreme programming was perfectly suited for my environment. Because of circumstances of my internship such as the duration being shortened due to the COVID-19 pandemic, I was involved in a very small team (just another intern and myself) and the project given to us had a very broad goal. PULSE is responsible for maintaining and updating the debit transaction network for Discover and other clients/banks. Our project's goal was to develop a Spring Java app to visualize the daily movement of transactions through the payments network, we were not given any requirements in terms of what fields we had to display (ISO8583 is the file format for financial transactions and has hundreds of attributes) and were only asked to create a basic interface as a proof-of-concept. Following the practices of XP, I split certain tasks with my pair and got a lot of work done by trusting that our designated sections of the software's development were correct. Through daily stand-up meetings we updated the team on the app's progress and were given more requirements as the development continued. Because we were focusing on certain functionality at a time, we were able to get the work done very quickly and meet our time constraints. For this purpose XP was very useful but a main concern was that the executive staff of our team liked our proof-of-concept and asked for us to create designs such that the application could be evolved into a completed software for company use (such that a separate team can continue development after out internship concluded). My pair and I realized that the software entropy for our application was abysmal, as such it was impractical to create diagrams and as we examined the source code again we found many redundant functions and objects. It was a very valuable lesson that even with XP, there needs to be a concerted effort to plan the design of the application for the purpose of preserving the software entropy and allowing other teams to take over and continue development.

