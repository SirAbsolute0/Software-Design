HW4 Due 11:59PM April 28

***Please review the top part of ../hw1/hw1.txt***
***There will be no reviews for this Homework***
***Please remember to follow the things that were emphasized throughout this course on writing***
***Please see the details in the requestReviews.txt file***

Feel free to give answers collectively, and also if you want to, you can call out something specific to yourself different from your team member. Bring out your learnings and reflect on them here.

1. What did you essentially learn in this course about design?
                                
Please provide individual responses to this question here (state your name and write in short paragraphs below that).

Phuong Dinh:
Throughout the course, I have learned about the importance of design in the software development cycle. Specifically, how applying design principles such as DRY, SRP, OCP, and many more, can significantly reduce the overall development time and increase software flexibility in the future.

Before the course, my general conception of a design in software development was a static diagram of classes and functions used as a guideline when developing a program. While a design guideline has benefits, such as being a road map during development, I have always believed it unnecessary. Thus, I have always neglected to think about the design unless required. However, the course showed me design in software development is much more than a static diagram. It is a combination of principles, design patterns, and dynamic diagrams. Furthermore, software design brings numerous benefits besides being a road map.

For example, utilizing the software design principles helps reduce clutter, increase code flow, make the code more flexible, document code, and ensure long-term manageability. In further detail, the DRY principle forces me to break my habit of copying and pasting code from one function to another. Thus, DRY reduces unnecessary cluttering throughout my code, making it easier to understand and follow. On the other hand, SRP shows me that a function does not need to be complex. On the contrary, an operation should be as simple as possible and only do what is required, nothing more. Anything not logically within the scope of the function name should be put in a separate function. SRP increases the code flow since my functions and classes are now adequately laid out with detailed naming scheme showing their purposes. TDD principle not only adds a new layer of confidence in my code but also acts as a documentation of how my code is through consistent unit testing. The unit tests will always notify me when a change I make in the future ripple through the code and affect a core functionality of the program. Therefore, I can confidently expand the program with new features without always needing to recheck previous work. TDD is a fantastic way to sustain the program's longevity; future developers can study the test cases to understand the code further.

Overall, the design principles I have learned to appreciate in the course have multiple advantages, which include reducing clutter, improving flow, future-proof, and documenting a program code base. All of these advantages can reduce development hours in personal projects and potentially millions of dollars in large-scale professional software. Thus, I believe it is essential to continue utilizing these design principles in the future to increase overall code quality.


Federico Nocioni:
This course was a great learning opportunity to learn more about varying aspects of software development that I often overlooked in the past both in my professional and academic work. By taking this course I learnt a lot more about varyious design principles and different approaches to design especially test driven development.

When developing applications I often want to jump in by programming and transforming my ideas into code instead of taking a step back to evaluate the design. In my experience, negligent design will cause any application to suffer later on in the future, whether it be due to entropy or an extension/modification of the requirements. Another problem that I often encounter is that I may reuse certain sections of code across multiple projects but have a hard time understanding the original motivation for how I designed specific functionality. 

One of the biggest takeaways from this course is that we can often make decisions in design for the goal of our work to be self-descriptive and intuitive in the case that other developers continue the work or I revisit it after a long time. For example, all constructs in code (variables, functions, classes, interfaces, etc..) must be names appropriately at the correct domain for the problem being addressed. There must also be a logical evolution for the code being written; This relates to how requirements are being satisfied in a product and ties in closely with the Test driven development (TDD) and its importance. Test driven development was a highlight of this course as we had to ensure that we slowly evolved our programs towards meeting the final requirements. As mentioned before, this design process helps minimize software entropy and provides flexibility to extend the program in the future and adapt to changing requirements. 

I was really glad that I took this course as it changed my outlook on the quality of my work. In professional settings we rarely work alone on code, as such we need to be more conscious about the way we name constructs and how we develop tests to cover the set of requirements in the program. Ideally, the code should be self-descriptive, flexible, and intuitive when read by other developers and third-parties.


2. What are some of the general guidelines you would follow when designing?

Throughout the course, my teammate and I have discovered the importance of software design. Some of the advantages of a good design are elevating the readability of the code, increasing confidence during development, providing a solid foundation for future updates, and documenting the code for future usage. All these advantages can save development time and increase work flexibility significantly in any project. Although we have only seen the surface of software design, we agree to utilize various methods in the course for our future projects. Specifically, using the path that starts with drawing a diagram of the problem, then using the test-first development method only to implement necessary features, and during development, make sure the code complies with DRY, SRP, OCP, and YAGNI; finally, apply a design pattern if needed.

We both believe that having a general diagram at the start of any project is essential. Not only does the diagram act as a general guideline for the code, but it is also a great communication device between team members. During assignments one and two, having the design helped us understand each other intentions when working on the same program. The diagram is handy because we have only started working with each other and knew little about the other person's preferences and styles. Furthermore, the diagram can continuously be updated throughout the development process, and eventually, it can be disregarded. 

Following the diagram, we both saw the greatness of test-driven development method and wanted to utilize it more. Specifically, test-driven development, or TDD, ensures the core functionalities always work despite updates. The update could be from a refactor or adding new features; as long as the tests pass, the program still works at a core level. Having the confidence to know exactly when and where the program failed is fantastic and can save much time during development. Furthermore, the bigger the project, the bigger the effects of TDD on the team's workflow. The tests can also be repurposed as documentation for future team members, which is fantastic. 

Throughout development, applying the DRY, SRP, OCP, and many more principles is excellent for ensuring the readability of the program and flow. Although the effects of these principles are not as significant as TDD, they are still needed, in our opinion. Like an essay, code is also written to be read by people. Therefore, code must also have a proper flow and be readable by others. Applying DRY, SRP, OCP, and other principles keeps the code consistent and concise, each serving only a single purpose and needing to fulfill its duty, nothing else. In turn, a well-kept code is reusable in the future and by others, increasing the group's overall work productivity.

Lastly, we agree that if we see a problem that can be solved with a design pattern, we should try to apply the pattern. Despite not having much time to apply the patterns during our assignments, from the example in the lectures, we see the patterns' usage. Previously proven patterns can be a savior when the problem aligns with the examples since we do not need to reinvent the solution and can utilize the given solutions. Thus, it will save us time and effort, which can be focused on other parts of the program. However, we also recognize that we should not try to force a pattern on a problem; it should come naturally during development. 

All in all, my teammate and I are shocked by the depth of the software design, its functionalities, and its benefits. The course was an excellent opportunity to familiarize ourselves with these new design concepts. After the course, we will continue to apply these principles in our personal and professional projects.