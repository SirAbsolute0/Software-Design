HW3 Due 11:59PM April 21

***Please review the top part of ../hw1/hw1.txt***
***Your chance of success greatly increases if you start very early. Your chance of failure increases if you start late. Please use as many reviews as you possibly can.***

1. According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far.

According to the article, there are four rules to simple design: passes the tests, reveals intention, no duplication, and fewest elements. These rules are essential to software development because it separates well-design, scalable, and maintainable code from poorly-designed and hard-to-understand code. Having a well-design code base provides flexibility for additional features in the future while still maintaining the core functionality of the original design, which can massively affect the revenue of any software-related business since a well-design code foundation will minimize the amount of time relearning and rebuilding. We have consistently applied these techniques throughout the assignments, specifically through the TDD, SRP, DRY, and YAGNI principles which have shown significant benefits in the development cycle of our works. 

Ranking in order of importance, Martin Fowler ranks passing the tests as the highest priority out of the four rules. The tests ensure that each functionality of the program works as intended; thus, if the tests pass, it means that, at the bare minimum, the functionality tie to each test case is working correctly. As the program increases in complexity, so will the importance of these tests, as they give the developers confidence that the newly added functionalities do not alter any previous work. In practice, if each program's functionality has its test case, the developers will never have to worry about a program misbehaving when developing new functionalities. In business, while it is not feasible to cover the program with every test case, if the program's core functionality is ensured with proper tests, at least the program will continue to perform its main tasks for the users during the development cycle of a new feature. 

Throughout the past assignments, we have applied the TDD principle to always have the tests before implementing minimal code to pass the tests. Each test aims to ensure that our program's core functionality will work independently of any change in the program. For example, in assignments one and two, we consistently utilized TDD to build parts of the Wordle game. Afterward, when it came to adding the UI to the program, despite making changes to the core logic code, we immediately knew which parts of the logic were working correctly and which were misbehaving because of the tests. The tests save us many hours of debugging, even in a small project of two people. 

The second level of importance includes both revealed intention and no duplication. It is critical to reveal intention because code is not only written for machines but also for people. Similar to an essay, the flow of a program should be cohesive and flow smoothly from function to function. It is also essential to be specific and consistent with the naming scheme, as different developers can interpret undefined variables and function names differently. Thus, it can cause many unnecessary headaches in the development cycle with multiple working on the same program. Fortunately, revealing intention in software is not costly to implement. Specifically, it only requires the self-discipline of each developer in a team to have a good naming scheme for their parts in the design. If implemented correctly, the benefits of having well-revealed code for a business or project are massive since it is easier to alter, add new functionalities, and maintain by new developers. 

In our case, we implemented reveal intention through SRP. We applied SRP to ensure that each function only handles a single purpose and nothing more. Thus, it keeps the flow of the code consistent throughout the program. Furthermore, we have names of functions and variables that reflect their purposes to limit miscommunication between ourselves. 

Of equal importance to revealing intention, no duplication is also crucial for a good design. In many ways, no duplication helps reveal intention because it reduces clutter inside a program, which helps the program flow. Furthermore, duplication in code can cause a ripple effect throughout the code if one copy is changed while another is not. Consistency is essential, and a function change should reflect everywhere else the function is present. In practice and business, having no duplication increases the development time slightly in the present but significantly reduces the refactoring time in the future. 

Specifically, we utilized the DRY principle to limit duplication code in our assignments. For instance, in assignment 3, we had to learn to use decorators to uphold the DRY principle. Decorators limited the creation of multiple condition check functions between the different implementations of the Fibonacci calculator. Thus, if we ever needed to change the condition to calculate the Fibonacci number, we would only need to change one function.

DRY was constantly applied in our code to reduce the duplication of functions with similar purposes. Several parts of the program require similar sets of inputs to be processed; however, the outputs can vary on the different inputs. Rather than copying the same code sequence to achieve a similar result multiple times, we delegated a specific function with the sequence and only called the new function. For example, we delegated a sequence to the countNumberOfOccurrenceeUntilPosition function in assignment two. After which, we only called countNumberOfOccurrenceeUntilPosition if we ever needed to reuse the same calculation. Specifically, we called the countNumberOfOccurrenceeUntilPosition function two times in the assignment, which reduced the code duplication in assignment two.

The fewest elements rule is the last of the four at the lowest priority. The fewest elements rule is if "anything that does not serve the three prior rules should be removed." The last rule helps limit unnecessary complexity during development. Like no duplication, it also helps decrease clutter, increase code flow, and increase cohesiveness. However, it does not immediately affect the program since having more complexity does not change how it functions. Still, it is a crucial rule to reduce the work hours of developers on non-essential complexity while changing their focus on tasks with higher priority. 

The fewest element rule correlates to the YAGNI principle, where whatever we do not need, we should not keep it. The YAGNI rule prevented us from overcomplicating any of our code implementations. Any code that did more than it needed to do was removed. Specifically, in assignment four, our implementation of the dynamic discover vendor was scrapped for a simpler version, but the functionality remained the same.

In cases where there is a conflict of interest between the different rules, the priority ranking shows which rule to prioritize first over others. In the article, Martin ranks passing the test as the first level, with no duplication, and revealed intention in the second level, and the fewest elements rule at the lowest level. It would be TDD, DRY, SRP, and YAGNI regarding design principles. We encountered a conflict between the principles in our assignments as well. 
More specifically, during assignment four, we had to choose between upholding TDD or DRY. Since we did not have enough time to devise a solution to uphold DRY, we copied some code to finish the function for TDD. While it was a necessary decision, we still violated one of the four principles during our design.

Overall, the four simple design rules are passing the tests, revealing intention, no duplication, and having the fewest elements. Each of them brings benefits to software during and after the development cycle. Some benefits are increased code cohesiveness, reduced duplicate work, better manageability, and maintainability in the future. We have applied these four rules throughout the past assignments using TDD, DRY, SRP, and YAGNI, which have shown significant benefits.

2. Also give from examples outside of this class, but limit to your personal experiences. Mention your name and below that provide details of your experience related to the rules, but outside of this class.

Phuong Dinh:

While I have not worked in an environment where I can apply the four rules of simple design, I am considering incorporating them in my next project. Specifically, I want to implement the TDD and DRY principles in my upcoming projects.

The work I have done previously for my personal, class, or professional projects has always been prototype-like, with a small team of about three members. Thus, I found it challenging to spend precious development time adhering to the four rules of simple design. However, after implementing these rules through different designing principles such as YAGNI, DRY, SRP, OCP, etc. It is becoming increasingly apparent that I must apply the four directions to design a proper program for current usage and future maintainability.

For example, I now appreciate test cases much more because I recently added a new feature to my program, which broke the logic of the program. I had to spend multiple days tracking down where the error logic was coming from since it went through numerous function calls. I am confident that problems like this will continue as the program becomes increasingly complex. Eventually, the design would need to be rewritten entirely, or nobody, including myself, could understand the code anymore.

Another example is my previous projects do have a lot of duplication code. While I intended to reuse functions as much as possible, I often felt like the time spent researching how to implement the functions correctly was not worth it. Thus, I neglected the duplication code until it piled up slowly. If I needed to change one part, I would need to do the same for ten more implementations. Therefore, I am looking into incorporating YAGNI, DRY, and SRP into my following projects to see the effectiveness of the principles toward my workflow.

Federico Nocioni:

I have experienced this approach to design once outside of academic work during my time as an Application Engineer intern at Pulse Discover. The company offers a fault-tolerant nonstop debit processing service to banks around the United States as well as several smaller banks and credit unions. The interns were tasked with creating a visualization tool for transaction information, as a team we decided to proceed with TDD as we were working on different aspects of the program concurrently. 

Before we began writing code we met as a team to come together on some of the basic tests that had to pass in order for us to continue advancing to other requirements. For example, I was in charge of developing the UI which gave the user options to customize a dynamic chart for transactions over a designated period of time. I had agreed on receiving a specific data structure from the developer working on the database; As such, building the basic tests around this data structure and making sure they pass before moving into other aspects of the program helped me keep the software entropy as low as possible. 

Another example of how I used these rules in the past (without being explicitly being aware of them) is during the development of my project for the Intermediate Game Development course. One of the most important things in this project was to separate the objectives across classes (SRP) such that it was much easier to debug the game in the future. Before taking that particular course, I found that I had a very bad habit of writing a lot of the code for my games in the same folder or even in the same class. 

A specific example of how we separated the components of the game include how we implemented the path-finding algorithm for the NPCs (non-player character). Usually I would design the path-finding algorithm from inside the NPC classes but for this class I had changed my approach and created a separate class that controlled the path-finding based off of a series of parameters that described different NPCs. By doing this I was able to achieve 2 of the 3 main objectives: revealing the intention of code as well as removing duplicate code (DRY); Instead of duplicating the path-finding algorithm with small changes for each NPC (specific terrain was only traversable by specific NPCs), all the code for path-finding was found in one class that all NPCs called to retrieve their path-finding decisions.

These approaches to design may take longer to develop at the beginning but definitely pay off in terms of minimizing software entropy. 
