HW4 Due 11:59PM April 28

***Please review the top part of ../hw1/hw1.txt***
***There will be no reviews for this Homework***
***Please remember to follow the things that were emphasized throughout this course on writing***
***Please see the details in the requestReviews.txt file***

Feel free to give answers collectively, and also if you want to, you can call out something specific to yourself different from your team member. Bring out your learnings and reflect on them here.

1. What did you essentially learn in this course about design?
                               
Phuong Dinh:
Throughout the course, I have learned about the importance of design in the software development cycle. Specifically, applying design principles such as DRY, SRP, OCP, and many more, can significantly reduce the overall development time and increase software flexibility.

Before taking software design, my general conception of a design in software was a static diagram of classes and functions used as general guidelines. While having a guideline have benefits, such as being a road map during development, I have always believed it to be unnecessary. Thus, I have always neglected the design portion unless required. However, the course showed me that software design is more than a static diagram. It is a combination of principles, design patterns, and dynamic diagrams. Furthermore, software design brings numerous benefits besides being a road map.

For example, utilizing the software design principles helps reduce clutter, increase code flow, make the code more flexible, document code, and ensure long-term manageability. In further detail, the DRY principle forces me to break my habit of copying and pasting code from one function to another. Thus, DRY reduces unnecessary clutter throughout my code, making it easier to understand and follow. On the other hand, SRP shows me that a function does not need to be complex. On the contrary, an operation should be as simple as possible and only do what is required, nothing more. Anything not logically within the scope of the function name should be put in a separate function. SRP also increases the code flow since my functions and classes are now adequately laid out with detailed naming scheme showing their purposes. 

Besides DRY and SRP, the TDD principle adds a new layer of confidence in my code and acts as a documentation of how my code is through consistent unit testing. The unit tests will always notify me when a change I make ripple through the code and affect a core functionality of the program. Therefore, I can confidently expand the program with new features without always needing to recheck previous work. In addition, TDD is a fantastic way to sustain the program's longevity, as future developers can study the test cases to understand the code.

Overall, the design principles I have learned to appreciate in the course have multiple advantages, which include reducing clutter, improving flow, future-proofing, and documenting a program code base. Aff of these advantages can reduce development hours in personal projects and potentially mitigate millions of dollars in large-scale professional software. Thus, I believe it is essential to continue utilizing these design principles in the future to increase overall code quality.

Federico Nocioni:
Software Design was a great learning opportunity to learn more about varying aspects of software development that I often overlooked in the past, both in my professional and academic work. This course taught me a lot about various design principles and different approaches to design, especially test-driven development.

When developing applications, I often want to jump in through programming and transform my ideas into code instead of taking a step back to evaluate the design. However, in my experience, a negligent design will cause any application to suffer later on in the future, whether it be due to entropy or an extension/modification of the requirements. Another problem I often encounter is that I may reuse certain sections of code across multiple projects but have difficulty understanding the original motivation for how I designed specific functionality. 

One of the biggest takeaways from this course is that we can often make decisions in design to make our code self-descriptive and intuitive. Specifically when other developers will continue the job or I will revisit it after some time. For example, all constructs in code (variables, functions, classes, interfaces, etc..) must be named appropriately at the correct domain for the problem being addressed. There must also be a logical evolution for the code being written; This relates to how requirements are being satisfied in a product and ties in closely with the Test-driven development (TDD) and its importance. Test-driven development was a highlight of this course as we had to ensure that we slowly evolved our programs toward meeting the final requirements. As mentioned before, this design process helps minimize software entropy and provides flexibility to extend the program in the future and adapt to changing needs. 

I was thrilled that I took this course, as it changed my outlook on the quality of my work. In professional settings, we rarely work alone on code; as such, we need to be more conscious about how we name constructs and develop tests to cover the set of requirements in the program. Ideally, the code should be self-descriptive, flexible, and intuitive when read by other developers and third parties.

2. What are some of the general guidelines you would follow when designing?

Throughout the course, my teammate and I have discovered the importance of software design. Some of the advantages of a good design are elevating the readability of the code, increasing confidence during development, providing a solid foundation for future updates, and documenting the code for future usage. All these advantages can save development time and increase work flexibility significantly in any project. Although we have only scratched the surface of software design, we agree to utilize various methods in the course for our future projects. Specifically, using the path that starts with drawing a diagram of the problem, then using the test-first development method only to implement necessary features, and during development, make sure the code complies with DRY, SRP, OCP, and YAGNI; finally, apply a design pattern if needed.

We both believe that having a general diagram at the start of any project is essential. Not only does the diagram act as a general guideline for the code, but it is also a great communication device between team members. During assignments one and two, having the design helped us understand each other intentions when working on the same program. The diagram is handy because we have only started working with each other and knew little about the other person's preferences and styles. Furthermore, the diagram can continuously extend throughout the development process, and eventually, it can disappear. 

Following the diagram, we both saw the greatness of test-driven development method and wanted to utilize it more. Specifically, test-driven development, or TDD, ensures the core functionalities always work despite updates. The update could be from a refactor or adding new features; as long as the tests pass, the program still works at a core level. Having the confidence to know exactly when and where the program failed is fantastic and can save much time during development. Furthermore, the bigger the project, the bigger the effects of TDD on the team's workflow. The tests can also transform into documentation for future team members, which is fantastic. 

Throughout development, applying the DRY, SRP, OCP, and many more principles is excellent for ensuring the program's readability and flow. Although the effects of these principles are not as significant as TDD, they are still needed, in our opinion. Like an essay, code is also written to be read by people. Therefore, code must also have a proper flow and be readable by others. Applying DRY, SRP, OCP, and other principles keeps the code consistent and concise, each serving only a single purpose and needing to fulfill its duty, nothing else. In turn, a well-kept code is reusable in the future and by others, increasing the group's overall work productivity.

Lastly, we agree that if we see a problem solvable with a design pattern, we should try to apply the pattern. Despite not having much time to apply the patterns during our assignments, we see the patterns' usage from the example in the lectures. Previously proven patterns can be a savior when the problem aligns with the examples since we do not need to reinvent the solution and can utilize the given solutions. Thus, it will save us time and effort, which can reflect in other parts of the program. However, we also recognize that we should not try to force a pattern on a problem; it should come naturally during development. 

All in all, our team is shocked by the depth of the software design, its functionalities, and its benefits. The course was an excellent opportunity to familiarize ourselves with these new design concepts. After the course, we will continue to apply these principles in our personal and professional projects.

Total [10]: 10
